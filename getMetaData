"""
File Metadata Analyzer - PySide6 Chunked Version
Optimized for extremely large folder structures (100K+ files)
Processes and exports in chunks to prevent freezing and memory issues
"""

import sys
import os
import pandas as pd
from pathlib import Path
from datetime import datetime
from typing import Optional
import threading
import json

from PySide6.QtWidgets import (
    QApplication, QMainWindow, QWidget, QVBoxLayout, QHBoxLayout,
    QPushButton, QLabel, QLineEdit, QFileDialog,
    QProgressBar, QMessageBox, QTableWidget, QTableWidgetItem,
    QHeaderView, QGroupBox, QAbstractItemView, QSpinBox, QCheckBox
)
from PySide6.QtCore import Qt, Signal, QObject, QThread
from PySide6.QtGui import QFont, QPalette, QColor

try:
    import win32security
    import pywintypes
    WIN32_AVAILABLE = True
except ImportError:
    WIN32_AVAILABLE = False
    print("Warning: pywin32 not available. File ownership information will not be collected.")


class WorkerSignals(QObject):
    """Signals for worker thread"""
    progress = Signal(int, int, int)  # progress_value, current, total
    chunk_saved = Signal(str, int)  # filepath, chunk_number
    finished = Signal(int, int)  # total_files, total_chunks
    error = Signal(str)
    status = Signal(str)
    folder_found = Signal(str)  # Show current folder being scanned
    stopped = Signal(int, int)  # total_processed, chunks_saved when stopped


class ChunkedScanWorker(QThread):
    """Worker thread for scanning files with chunked processing"""
    
    def __init__(self, root_folder, output_folder, chunk_size=10000, resume_mode=False):
        super().__init__()
        self.root_folder = root_folder
        self.output_folder = output_folder
        self.chunk_size = chunk_size
        self.resume_mode = resume_mode
        self.signals = WorkerSignals()
        self.is_running = True
        self.saved_files = []
        self.progress_file = os.path.join(output_folder, ".scan_progress.json")
        self.processed_folders = set()
        
        # Load previous progress if resuming
        if resume_mode and os.path.exists(self.progress_file):
            try:
                with open(self.progress_file, 'r') as f:
                    data = json.load(f)
                    self.processed_folders = set(data.get('processed_folders', []))
            except:
                pass
        
    def get_file_owner(self, filepath):
        """Get the owner of a file (Windows)"""
        if not WIN32_AVAILABLE:
            return ""
        try:
            sd = win32security.GetFileSecurity(filepath, win32security.OWNER_SECURITY_INFORMATION)
            owner_sid = sd.GetSecurityDescriptorOwner()
            name, domain, type = win32security.LookupAccountSid(None, owner_sid)
            return f"{domain}\\{name}"
        except:
            return ""
            
    def get_file_metadata(self, filepath):
        """Extract comprehensive metadata from a file"""
        try:
            path_obj = Path(filepath)
            stat_info = path_obj.stat()
            
            # Basic info
            file_size = stat_info.st_size
            created_time = datetime.fromtimestamp(stat_info.st_ctime)
            modified_time = datetime.fromtimestamp(stat_info.st_mtime)
            
            # Access time (may not be available on all systems)
            try:
                accessed_time = datetime.fromtimestamp(stat_info.st_atime)
            except:
                accessed_time = None
                
            # Current time for calculations
            now = datetime.now()
            
            # Calculate time differences for created date
            days_since_created = (now - created_time).days
            months_since_created = days_since_created // 30 if days_since_created >= 30 else 0
            years_since_created = days_since_created // 365 if days_since_created >= 365 else 0
            
            # Calculate time differences for access date
            if accessed_time:
                days_since_accessed = (now - accessed_time).days
                months_since_accessed = days_since_accessed // 30 if days_since_accessed >= 30 else 0
                years_since_accessed = days_since_accessed // 365 if days_since_accessed >= 365 else 0
            else:
                days_since_accessed = ""
                months_since_accessed = ""
                years_since_accessed = ""
                
            # Get owner
            created_by = self.get_file_owner(filepath)
            
            metadata = {
                'Full File Path': str(path_obj.absolute()),
                'Directory Path': str(path_obj.parent.absolute()),
                'Folder Name': path_obj.parent.name,
                'File Name with Extension': path_obj.name,
                'File Name': path_obj.stem,
                'File Extension': path_obj.suffix,
                'File Size (Bytes)': file_size,
                'File Size (KB)': round(file_size / 1024, 2),
                'File Size (MB)': round(file_size / (1024 * 1024), 2),
                'Created Date': created_time.strftime('%Y-%m-%d %H:%M:%S'),
                'Created By': created_by,
                'Days Since Created': days_since_created,
                'Months Since Created': months_since_created,
                'Years Since Created': years_since_created,
                'Last Modified Date': modified_time.strftime('%Y-%m-%d %H:%M:%S'),
                'Last Accessed Date': accessed_time.strftime('%Y-%m-%d %H:%M:%S') if accessed_time else "",
                'Last Accessed By': "",  # Windows doesn't track this
                'Days Since Accessed': days_since_accessed,
                'Months Since Accessed': months_since_accessed,
                'Years Since Accessed': years_since_accessed,
            }
            
            return metadata
        except Exception as e:
            # Silently skip files that can't be accessed
            return None
            
    def save_chunk(self, chunk_data, chunk_number, timestamp, is_partial=False):
        """Save a chunk of data to CSV"""
        if not chunk_data:
            return None
            
        try:
            df = pd.DataFrame(chunk_data)
            partial_suffix = "_partial" if is_partial else ""
            filename = f"file_metadata_{timestamp}_chunk_{chunk_number:04d}{partial_suffix}.csv"
            filepath = os.path.join(self.output_folder, filename)
            df.to_csv(filepath, index=False, encoding='utf-8-sig')
            self.saved_files.append(filepath)
            return filepath
        except Exception as e:
            self.signals.error.emit(f"Error saving chunk {chunk_number}: {str(e)}")
            return None
    
    def save_progress(self, timestamp):
        """Save scan progress for resume capability"""
        try:
            progress_data = {
                'timestamp': timestamp,
                'root_folder': self.root_folder,
                'processed_folders': list(self.processed_folders),
                'chunk_size': self.chunk_size
            }
            with open(self.progress_file, 'w') as f:
                json.dump(progress_data, f, indent=2)
        except Exception as e:
            print(f"Warning: Could not save progress: {e}")
            
    def run(self):
        """Run the scanning process with chunked output"""
        try:
            if not self.root_folder or not os.path.exists(self.root_folder):
                self.signals.error.emit("Invalid root folder")
                return
                
            timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
            chunk_data = []
            chunk_number = 1
            total_processed = 0
            estimated_total = 0
            skipped_folders = 0
            
            if self.resume_mode and self.processed_folders:
                self.signals.status.emit(f"Resume mode: Skipping {len(self.processed_folders)} already-processed folders...")
            else:
                self.signals.status.emit("Starting scan... Discovering files and folders...")
            
            # Process files as we discover them (streaming approach)
            for dirpath, dirnames, filenames in os.walk(self.root_folder):
                if not self.is_running:
                    # Save partial chunk before stopping
                    if chunk_data:
                        self.signals.status.emit(f"Stopping... Saving partial chunk {chunk_number}...")
                        saved_path = self.save_chunk(chunk_data, chunk_number, timestamp, is_partial=True)
                        if saved_path:
                            self.signals.chunk_saved.emit(saved_path, chunk_number)
                    # Save progress for resume
                    self.save_progress(timestamp)
                    self.signals.stopped.emit(total_processed, chunk_number)
                    return
                
                # Skip if already processed (resume mode)
                if self.resume_mode and dirpath in self.processed_folders:
                    skipped_folders += 1
                    continue
                
                # Show current folder being scanned
                folder_status = f"Scanning: {dirpath}"
                if self.resume_mode:
                    folder_status += f" (Skipped: {skipped_folders})" 
                self.signals.folder_found.emit(folder_status)
                
                # Process files in this directory
                for filename in filenames:
                    if not self.is_running:
                        # Save partial chunk before stopping
                        if chunk_data:
                            self.signals.status.emit(f"Stopping... Saving partial chunk {chunk_number}...")
                            saved_path = self.save_chunk(chunk_data, chunk_number, timestamp, is_partial=True)
                            if saved_path:
                                self.signals.chunk_saved.emit(saved_path, chunk_number)
                        # Save progress for resume
                        self.save_progress(timestamp)
                        self.signals.stopped.emit(total_processed, chunk_number)
                        return
                    
                    filepath = os.path.join(dirpath, filename)
                    metadata = self.get_file_metadata(filepath)
                    
                    if metadata:
                        chunk_data.append(metadata)
                        total_processed += 1
                        
                        # Update progress
                        self.signals.progress.emit(
                            len(chunk_data) * 100 // self.chunk_size,
                            total_processed,
                            estimated_total if estimated_total > 0 else total_processed
                        )
                        
                        # Save chunk when it reaches the specified size
                        if len(chunk_data) >= self.chunk_size:
                            self.signals.status.emit(f"Saving chunk {chunk_number}...")
                            saved_path = self.save_chunk(chunk_data, chunk_number, timestamp)
                            
                            if saved_path:
                                self.signals.chunk_saved.emit(saved_path, chunk_number)
                                chunk_number += 1
                                chunk_data = []  # Clear chunk for next batch
                                
                                # Save progress periodically
                                if chunk_number % 5 == 0:
                                    self.save_progress(timestamp)
                
                # Mark folder as processed
                self.processed_folders.add(dirpath)
                                
            # Save any remaining data
            if chunk_data:
                self.signals.status.emit(f"Saving final chunk {chunk_number}...")
                saved_path = self.save_chunk(chunk_data, chunk_number, timestamp)
                if saved_path:
                    self.signals.chunk_saved.emit(saved_path, chunk_number)
            
            # Clean up progress file on successful completion
            if os.path.exists(self.progress_file):
                try:
                    os.remove(self.progress_file)
                except:
                    pass
            
            self.signals.finished.emit(total_processed, chunk_number)
            
        except Exception as e:
            self.signals.error.emit(f"Error during scan: {str(e)}")
            
    def stop(self):
        """Stop the scanning process"""
        self.is_running = False


class FileAnalyzerWindow(QMainWindow):
    def __init__(self):
        super().__init__()
        
        self.output_folder = os.path.join(os.getcwd(), "Output")
        self.worker = None
        self.chunk_files = []
        self.is_scanning = False
        self.progress_file = os.path.join(self.output_folder, ".scan_progress.json")
        
        # Create Output folder if it doesn't exist
        os.makedirs(self.output_folder, exist_ok=True)
        
        self.init_ui()
        self.apply_styles()
        
    def init_ui(self):
        """Initialize the user interface"""
        self.setWindowTitle("File Metadata Analyzer - Chunked Processing (Large Folders)")
        self.setGeometry(100, 100, 1400, 800)
        
        # Central widget
        central_widget = QWidget()
        self.setCentralWidget(central_widget)
        
        # Main layout
        main_layout = QVBoxLayout(central_widget)
        main_layout.setSpacing(10)
        main_layout.setContentsMargins(20, 20, 20, 20)
        
        # Header
        header_layout = QVBoxLayout()
        title_label = QLabel("üìÅ File Metadata Analyzer (Chunked)")
        title_font = QFont()
        title_font.setPointSize(18)
        title_font.setBold(True)
        title_label.setFont(title_font)
        title_label.setAlignment(Qt.AlignCenter)
        header_layout.addWidget(title_label)
        
        subtitle_label = QLabel("Optimized for extremely large folder structures (100K+ files)")
        subtitle_label.setAlignment(Qt.AlignCenter)
        subtitle_label.setStyleSheet("color: gray;")
        header_layout.addWidget(subtitle_label)
        
        info_label = QLabel("‚ö° Processes and exports in chunks - Won't freeze even with millions of files!")
        info_label.setAlignment(Qt.AlignCenter)
        info_label.setStyleSheet("color: #2ecc71; font-weight: bold;")
        header_layout.addWidget(info_label)
        
        main_layout.addLayout(header_layout)
        
        # Control panel group
        control_group = QGroupBox("Controls")
        control_layout = QVBoxLayout()
        
        # Root folder selection
        folder_layout = QHBoxLayout()
        folder_layout.addWidget(QLabel("Root Folder:"))
        
        self.folder_input = QLineEdit()
        self.folder_input.setPlaceholderText("Select folder to scan...")
        folder_layout.addWidget(self.folder_input)
        
        self.browse_btn = QPushButton("üìÇ Browse")
        self.browse_btn.clicked.connect(self.browse_folder)
        folder_layout.addWidget(self.browse_btn)
        
        control_layout.addLayout(folder_layout)
        
        # Chunk size setting
        chunk_layout = QHBoxLayout()
        chunk_layout.addWidget(QLabel("Files per Chunk:"))
        
        self.chunk_size_input = QSpinBox()
        self.chunk_size_input.setMinimum(1000)
        self.chunk_size_input.setMaximum(100000)
        self.chunk_size_input.setValue(10000)
        self.chunk_size_input.setSingleStep(1000)
        self.chunk_size_input.setToolTip("Number of files to process before saving to a new file.\nSmaller = More frequent saves, Less memory usage\nLarger = Fewer files to combine later")
        chunk_layout.addWidget(self.chunk_size_input)
        
        chunk_layout.addWidget(QLabel("(Recommended: 5,000-20,000)"))
        chunk_layout.addStretch()
        
        self.scan_btn = QPushButton("üîç Start Chunked Scan")
        self.scan_btn.clicked.connect(self.start_scan)
        self.scan_btn.setStyleSheet("background-color: #2ecc71; color: white; font-weight: bold; padding: 10px 20px;")
        chunk_layout.addWidget(self.scan_btn)
        
        self.stop_btn = QPushButton("‚èπÔ∏è Stop Scan")
        self.stop_btn.clicked.connect(self.stop_scan)
        self.stop_btn.setEnabled(False)
        self.stop_btn.setStyleSheet("background-color: #e74c3c; color: white; font-weight: bold; padding: 10px 20px;")
        chunk_layout.addWidget(self.stop_btn)
        
        # Check if resume is available
        self.resume_btn = QPushButton("‚ñ∂Ô∏è Resume Scan")
        self.resume_btn.clicked.connect(self.resume_scan)
        self.resume_btn.setEnabled(self.can_resume())
        self.resume_btn.setStyleSheet("background-color: #f39c12; color: white; font-weight: bold; padding: 10px 20px;")
        chunk_layout.addWidget(self.resume_btn)
        
        control_layout.addLayout(chunk_layout)
        
        # Output folder selection
        output_layout = QHBoxLayout()
        output_layout.addWidget(QLabel("Output Folder:"))
        
        self.output_input = QLineEdit()
        self.output_input.setText(self.output_folder)
        output_layout.addWidget(self.output_input)
        
        self.output_btn = QPushButton("üìÇ Change")
        self.output_btn.clicked.connect(self.change_output_folder)
        output_layout.addWidget(self.output_btn)
        
        self.open_folder_btn = QPushButton("üìÅ Open Output Folder")
        self.open_folder_btn.clicked.connect(self.open_output_folder)
        output_layout.addWidget(self.open_folder_btn)
        
        control_layout.addLayout(output_layout)
        
        # Progress section
        progress_layout = QVBoxLayout()
        
        self.current_folder_label = QLabel("")
        self.current_folder_label.setStyleSheet("color: #95a5a6; font-size: 9pt;")
        self.current_folder_label.setWordWrap(True)
        progress_layout.addWidget(self.current_folder_label)
        
        self.status_label = QLabel("Ready to scan...")
        self.status_label.setStyleSheet("color: gray; font-weight: bold;")
        progress_layout.addWidget(self.status_label)
        
        self.progress_bar = QProgressBar()
        self.progress_bar.setValue(0)
        progress_layout.addWidget(self.progress_bar)
        
        self.stats_label = QLabel("")
        self.stats_label.setStyleSheet("color: #3498db; font-weight: bold;")
        progress_layout.addWidget(self.stats_label)
        
        control_layout.addLayout(progress_layout)
        
        control_group.setLayout(control_layout)
        main_layout.addWidget(control_group)
        
        # Results section
        results_header_layout = QHBoxLayout()
        results_label = QLabel("Saved Chunks")
        results_font = QFont()
        results_font.setPointSize(12)
        results_font.setBold(True)
        results_label.setFont(results_font)
        results_header_layout.addWidget(results_label)
        
        self.summary_label = QLabel("No chunks saved yet")
        self.summary_label.setStyleSheet("color: #3498db; font-weight: bold;")
        results_header_layout.addStretch()
        results_header_layout.addWidget(self.summary_label)
        
        main_layout.addLayout(results_header_layout)
        
        # Table widget for chunk list
        self.results_table = QTableWidget()
        self.results_table.setColumnCount(3)
        self.results_table.setHorizontalHeaderLabels(["Chunk #", "File Path", "Status"])
        self.results_table.setAlternatingRowColors(True)
        self.results_table.setSelectionBehavior(QAbstractItemView.SelectRows)
        self.results_table.setEditTriggers(QAbstractItemView.NoEditTriggers)
        self.results_table.horizontalHeader().setStretchLastSection(True)
        self.results_table.setColumnWidth(0, 80)
        self.results_table.setColumnWidth(2, 100)
        self.results_table.setStyleSheet("""
            QTableWidget {
                gridline-color: #444444;
                background-color: #1e1e1e;
                alternate-background-color: #2a2a2a;
            }
            QTableWidget::item {
                padding: 5px;
            }
            QHeaderView::section {
                background-color: #3c3c3c;
                padding: 5px;
                border: 1px solid #555555;
                font-weight: bold;
            }
        """)
        main_layout.addWidget(self.results_table)
        
        # Info footer
        info_footer = QLabel(
            "üí° TIP: Each chunk is saved immediately as CSV. "
            "You can combine them in Excel using Power Query (Data > Get Data > From Folder)"
        )
        info_footer.setStyleSheet("color: #f39c12; font-style: italic; padding: 10px;")
        info_footer.setWordWrap(True)
        main_layout.addWidget(info_footer)
        
    def apply_styles(self):
        """Apply dark theme styles"""
        self.setStyleSheet("""
            QMainWindow {
                background-color: #2b2b2b;
            }
            QWidget {
                background-color: #2b2b2b;
                color: #ffffff;
            }
            QGroupBox {
                border: 2px solid #444444;
                border-radius: 5px;
                margin-top: 10px;
                padding-top: 10px;
                font-weight: bold;
            }
            QGroupBox::title {
                subcontrol-origin: margin;
                left: 10px;
                padding: 0 5px 0 5px;
            }
            QLineEdit {
                background-color: #3c3c3c;
                border: 1px solid #555555;
                border-radius: 3px;
                padding: 5px;
                color: #ffffff;
            }
            QSpinBox {
                background-color: #3c3c3c;
                border: 1px solid #555555;
                border-radius: 3px;
                padding: 5px;
                color: #ffffff;
            }
            QPushButton {
                background-color: #3498db;
                color: white;
                border: none;
                border-radius: 3px;
                padding: 8px 15px;
                font-weight: bold;
            }
            QPushButton:hover {
                background-color: #2980b9;
            }
            QPushButton:pressed {
                background-color: #21618c;
            }
            QPushButton:disabled {
                background-color: #555555;
                color: #888888;
            }
            QTableWidget {
                gridline-color: #444444;
                background-color: #1e1e1e;
                border: 1px solid #555555;
            }
            QProgressBar {
                border: 1px solid #555555;
                border-radius: 3px;
                text-align: center;
                background-color: #3c3c3c;
            }
            QProgressBar::chunk {
                background-color: #3498db;
                border-radius: 2px;
            }
        """)
        
    def browse_folder(self):
        """Open folder browser dialog"""
        folder = QFileDialog.getExistingDirectory(
            self,
            "Select Root Folder to Scan",
            "",
            QFileDialog.ShowDirsOnly | QFileDialog.DontResolveSymlinks
        )
        if folder:
            # Try to convert drive letter to UNC path
            if len(folder) >= 2 and folder[1] == ':':
                try:
                    import subprocess
                    result = subprocess.run(
                        ['net', 'use', folder[:2]],
                        capture_output=True,
                        text=True,
                        timeout=5
                    )
                    if result.returncode == 0:
                        for line in result.stdout.split('\n'):
                            if 'Remote name' in line or 'Remote Name' in line:
                                unc_path = line.split()[-1]
                                if unc_path.startswith('\\\\'):
                                    # Found UNC path, add the rest of the folder path
                                    rest_of_path = folder[2:].lstrip('\\')
                                    full_unc = unc_path.rstrip('\\') + '\\' + rest_of_path if rest_of_path else unc_path
                                    
                                    response = QMessageBox.question(
                                        self,
                                        "Network Drive Detected",
                                        f"Mapped drive detected: {folder[:2]}\n\n"
                                        f"UNC Path: {full_unc}\n\n"
                                        f"For reliable resume functionality, UNC paths are recommended.\n\n"
                                        f"Use UNC path instead?",
                                        QMessageBox.Yes | QMessageBox.No
                                    )
                                    
                                    if response == QMessageBox.Yes:
                                        folder = full_unc
                                    break
                except:
                    pass  # If conversion fails, use original path
            
            self.folder_input.setText(folder)
            
    def change_output_folder(self):
        """Change output folder location"""
        folder = QFileDialog.getExistingDirectory(
            self,
            "Select Output Folder",
            "",
            QFileDialog.ShowDirsOnly | QFileDialog.DontResolveSymlinks
        )
        if folder:
            self.output_folder = folder
            self.output_input.setText(folder)
            os.makedirs(folder, exist_ok=True)
            
    def open_output_folder(self):
        """Open the output folder in file explorer"""
        if os.path.exists(self.output_folder):
            os.startfile(self.output_folder)
        else:
            QMessageBox.warning(self, "Warning", "Output folder does not exist yet")
    
    def can_resume(self):
        """Check if a previous scan can be resumed"""
        return os.path.exists(self.progress_file)
    
    def clear_resume_data(self):
        """Clear resume progress file"""
        if os.path.exists(self.progress_file):
            try:
                os.remove(self.progress_file)
                self.resume_btn.setEnabled(False)
            except Exception as e:
                QMessageBox.warning(self, "Warning", f"Could not clear resume data: {e}")
            
    def start_scan(self, resume_mode=False):
        """Start scanning in a worker thread"""
        root = self.folder_input.text()
        
        if not root or not os.path.exists(root):
            QMessageBox.critical(self, "Error", "Please select a valid root folder")
            return
        
        # If starting fresh, ask about existing resume data
        if not resume_mode and self.can_resume():
            response = QMessageBox.question(
                self,
                "Resume Previous Scan?",
                "Found a previous incomplete scan. Do you want to:\n\n"
                "‚Ä¢ Resume - Continue from where you left off\n"
                "‚Ä¢ Start Fresh - Begin a new scan (clears progress)\n\n"
                "Choose Resume to skip already-processed folders.",
                QMessageBox.Yes | QMessageBox.No | QMessageBox.Cancel,
                QMessageBox.Yes
            )
            
            if response == QMessageBox.Cancel:
                return
            elif response == QMessageBox.Yes:
                resume_mode = True
            else:
                # Clear resume data for fresh start
                self.clear_resume_data()
            
        # Disable/Enable buttons during scan
        self.scan_btn.setEnabled(False)
        self.resume_btn.setEnabled(False)
        self.browse_btn.setEnabled(False)
        self.stop_btn.setEnabled(True)
        self.is_scanning = True
        
        self.progress_bar.setValue(0)
        status_text = "Resuming scan..." if resume_mode else "Starting scan..."
        self.status_label.setText(status_text)
        
        if not resume_mode:
            self.chunk_files = []
            # Clear previous results
            self.results_table.setRowCount(0)
            self.summary_label.setText("Scanning in progress...")
        
        # Get chunk size
        chunk_size = self.chunk_size_input.value()
        
        # Create and start worker thread
        self.worker = ChunkedScanWorker(root, self.output_folder, chunk_size, resume_mode)
        self.worker.signals.progress.connect(self.update_progress)
        self.worker.signals.chunk_saved.connect(self.chunk_saved)
        self.worker.signals.finished.connect(self.scan_finished)
        self.worker.signals.stopped.connect(self.scan_stopped)
        self.worker.signals.error.connect(self.scan_error)
        self.worker.signals.status.connect(self.update_status)
        self.worker.signals.folder_found.connect(self.update_current_folder)
        self.worker.start()
    
    def resume_scan(self):
        """Resume a previous scan"""
        # Show resume information
        if os.path.exists(self.progress_file):
            try:
                with open(self.progress_file, 'r') as f:
                    data = json.load(f)
                    processed_count = len(data.get('processed_folders', []))
                    root_folder = data.get('root_folder', 'Unknown')
                    timestamp = data.get('timestamp', 'Unknown')
                    
                    response = QMessageBox.question(
                        self,
                        "Resume Scan Info",
                        f"Previous scan details:\n\n"
                        f"üìÅ Root Folder:\n   {root_folder}\n\n"
                        f"‚è±Ô∏è Last Run: {timestamp}\n"
                        f"‚úÖ Processed Folders: {processed_count:,}\n\n"
                        f"These folders will be SKIPPED.\n"
                        f"Only new/unscanned folders will be processed.\n\n"
                        f"Continue with resume?",
                        QMessageBox.Yes | QMessageBox.No
                    )
                    
                    if response == QMessageBox.No:
                        return
            except Exception as e:
                QMessageBox.warning(self, "Warning", f"Could not read progress file: {e}")
                return
        
        self.start_scan(resume_mode=True)
    
    def stop_scan(self):
        """Stop the current scan"""
        if self.worker and self.is_scanning:
            response = QMessageBox.question(
                self,
                "Stop Scan?",
                "Do you want to stop the scan?\n\n"
                "Current partial chunk will be saved.\n"
                "You can resume later from where you left off.",
                QMessageBox.Yes | QMessageBox.No
            )
            
            if response == QMessageBox.Yes:
                self.status_label.setText("Stopping scan...")
                self.worker.stop()
        
    def update_progress(self, progress, current, total):
        """Update progress bar and labels"""
        self.progress_bar.setValue(min(progress, 100))
        self.stats_label.setText(f"Processed: {current:,} files")
        
    def update_status(self, status):
        """Update status label"""
        self.status_label.setText(status)
        
    def update_current_folder(self, folder_path):
        """Update current folder being scanned"""
        # Truncate long paths
        if len(folder_path) > 100:
            folder_path = "..." + folder_path[-97:]
        self.current_folder_label.setText(folder_path)
        
    def chunk_saved(self, filepath, chunk_number):
        """Handle chunk save event"""
        self.chunk_files.append(filepath)
        
        # Add row to table
        row_position = self.results_table.rowCount()
        self.results_table.insertRow(row_position)
        
        self.results_table.setItem(row_position, 0, QTableWidgetItem(f"Chunk {chunk_number}"))
        self.results_table.setItem(row_position, 1, QTableWidgetItem(filepath))
        
        status_item = QTableWidgetItem("‚úÖ Saved")
        status_item.setForeground(QColor("#2ecc71"))
        self.results_table.setItem(row_position, 2, status_item)
        
        # Update summary
        self.summary_label.setText(f"{len(self.chunk_files)} chunk(s) saved")
        
        # Scroll to latest
        self.results_table.scrollToBottom()
        
    def scan_finished(self, total_files, total_chunks):
        """Handle scan completion"""
        # Re-enable buttons
        self.scan_btn.setEnabled(True)
        self.browse_btn.setEnabled(True)
        self.stop_btn.setEnabled(False)
        self.resume_btn.setEnabled(False)
        self.is_scanning = False
        
        self.progress_bar.setValue(100)
        self.status_label.setText(f"‚úÖ Scan complete!")
        self.stats_label.setText(f"Total: {total_files:,} files in {total_chunks} chunk(s)")
        self.current_folder_label.setText("")
        
        QMessageBox.information(
            self,
            "Scan Complete",
            f"Successfully scanned {total_files:,} files!\n\n"
            f"Saved as {total_chunks} chunk file(s) in:\n{self.output_folder}\n\n"
            f"üí° You can now combine these CSV files in Excel using Power Query:\n"
            f"1. Open Excel\n"
            f"2. Go to Data > Get Data > From File > From Folder\n"
            f"3. Select the output folder\n"
            f"4. Click 'Combine' to merge all chunks into one table"
        )
    
    def scan_stopped(self, total_files, total_chunks):
        """Handle scan stopped by user"""
        # Re-enable buttons
        self.scan_btn.setEnabled(True)
        self.browse_btn.setEnabled(True)
        self.stop_btn.setEnabled(False)
        self.resume_btn.setEnabled(True)  # Enable resume
        self.is_scanning = False
        
        self.status_label.setText(f"‚è∏Ô∏è Scan stopped")
        self.stats_label.setText(f"Processed: {total_files:,} files in {total_chunks} chunk(s) before stopping")
        self.current_folder_label.setText("")
        
        QMessageBox.information(
            self,
            "Scan Stopped",
            f"Scan stopped by user.\n\n"
            f"Processed: {total_files:,} files\n"
            f"Saved: {total_chunks} chunk file(s)\n\n"
            f"‚úÖ All data has been saved!\n\n"
            f"üí° Click 'Resume Scan' to continue from where you left off.\n"
            f"   Already-processed folders will be skipped."
        )
        
    def scan_error(self, error_msg):
        """Handle scan error"""
        self.scan_btn.setEnabled(True)
        self.browse_btn.setEnabled(True)
        self.stop_btn.setEnabled(False)
        self.resume_btn.setEnabled(self.can_resume())
        self.is_scanning = False
        self.status_label.setText("‚ùå Error occurred during scan")
        QMessageBox.critical(self, "Scan Error", error_msg)


def main():
    app = QApplication(sys.argv)
    
    # Set application style
    app.setStyle('Fusion')
    
    window = FileAnalyzerWindow()
    window.show()
    
    sys.exit(app.exec())


if __name__ == "__main__":
    main()
